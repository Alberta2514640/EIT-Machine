# Functions that handle AWG mode, EIT mode, and serial transfers to the RP2040

import os
import io
import serial
import wavegen
import numpy as np
import matplotlib.pyplot as plt
from pyeit.mesh.external import load_mesh, place_electrodes_equal_spacing
from pyeit.visual.plot import create_mesh_plot, create_plot
import pyeit.eit.protocol as protocol
from pyeit.eit.jac import JAC

# Generates the necessary objects for use in EIT mode.
# For now, these values are hardcoded.
def gen_eit_objs(n_el:int, dist_el:np.float64, is_adj:bool):
    # The example file is oriented in the following manner:
    # Left towards the X axis
    # Anterior direction towards the Y axis
    # This allows the 2D mesh to be displayed in the radiological view with no transformations
    simulation_mesh_filename = (
        "EIT/JAC/Meshes/Circle.ply"
    )
    n_electrodes = 16

    # Set up the EIT mesh and place the electrodes equally around it.
    current_dir = os.path.dirname(os.path.abspath(__file__))
    sim_mesh = load_mesh(os.path.join(current_dir, simulation_mesh_filename))
    electrode_nodes = place_electrodes_equal_spacing(sim_mesh, n_electrodes=16)
    sim_mesh.el_pos = np.array(electrode_nodes)

    # TODO: We probably need to return this too, in order to create graphs
    fig, ax = plt.subplots()
    create_mesh_plot(
        ax, sim_mesh, electrodes=electrode_nodes, coordinate_labels="radiological"
    )

    # The protocol object generates the list of electrodes that we must excite and measure.
    protocol_obj = protocol.create(
        n_electrodes, dist_exc=1, step_meas=1, parser_meas="std"
    )

    # Recon
    # Set up eit object
    pyeit_obj = JAC(sim_mesh, protocol_obj)
    pyeit_obj.setup(p=0.5, lamb=0.001, method="kotre", perm=1, jac_normalized=False)

    return sim_mesh, protocol_obj, pyeit_obj

# Helper function for serial bulk sends
def bulk_send(buf):
    ser = serial.Serial("COM6", baudrate=9600)
    ser.reset_input_buffer()
    ser.reset_output_buffer()
    ser.flush()
    ser.write(buf)
    ser.close()
    pass

# Helper function for serial bulk receives
def bulk_receive(bytes_to_read:int):
    ser = serial.Serial("COM6", baudrate=9600, timeout=1)
    ser.reset_input_buffer()
    ser.reset_output_buffer()
    buf = ser.read(bytes_to_read)
    ser.flush()
    ser.close()
    return buf

# Function that implements EIT mode
def eit_mode():
    mesh, prot_obj, pyeit_obj = gen_eit_objs(16, None, None) # Options not implemented at the moment
    # Format the matrices for byte(8-bit)-level serial transfer
    int8_ext_mat = prot_obj.ex_mat.astype(dtype=np.int8)
    int8_mea_mat = prot_obj.meas_mat.astype(dtype=np.int8)
    # Explicitly put in C order, as Fortran order would cause parsing issues.
    int8_ext_bytes = int8_ext_mat.tobytes('C')
    int8_mea_bytes = int8_mea_mat.tobytes('C')
    # Send encoded text that kicks off the board's EIT mode
        # This function will automatically adjust channel 1 to start outputting a full-scale 50kHz sine with no phase shift.
        # It will also power down DDS 2, 3, 4, shut off all the DACs (except for channel 1), and restore them when EIT terminates.
        # It will also automatically restore the channel's previous values to
    # The RP2040 will start listening for the excitation and measurement pairs
    # Send the list of excitation pairs, then the list of measurement pairs
    bulk_send(len(int8_ext_bytes).to_bytes())
    bulk_send(int8_ext_bytes)
    bulk_send(len(int8_mea_bytes).to_bytes())
    bulk_send(int8_mea_bytes)
    while True: # Come up with a way to terminate this from the GUI
        # The RP2040 will start to periodically send a bitstream made up of 16-bit voltage measurements.
        # It will continue to do so as long as there is nothing in the buffer when it goes to send the next measurement.
        # This will be how we cancel out of EIT mode, by writing something to the buffer and flushing it from the RP2040's side
        # Receive the full list of measurements in 16-bit binary form (# in number of measurements)
        meas_vals = bulk_receive(prot_obj.n_meas_tot)
        # Update the vi value, calculate and plot the new version of the EIT.
        pass
    pass

# Function that implements AWG wave updates
# Send encoded text that matches with an AWG update function on the RP2040
# Send the 1024-byte SRAM update that is generated by wavegen.py
# The device on the other end is responsible for chopping off the top 4 MSBs.
def awg_update(amplitude, frequency, phase, type, ax:plt.axes):
    time, wave, data = wavegen.gen_graph(amplitude, frequency, phase, type)
    # Generate the
    pass